#R_code_exam_Yellowstone_burn_recovery

#In questo codice sul recupero delle zone colpite dall'incendio nel parco di Yellowstone nel 1988:
#-confronteremo le varie immagini scaricate dal sito NASA Earth Observatory https://earthobservatory.nasa.gov/world-of-change/Yellowstone e salvate nella cartella "yellowstone" nel disco locale C in una Times series 1987-2018,
#-verrà poi calcolato variabilità multitemporale e NDVI  #library(raster) #library(rasterVis) per levelplot
#-verrà operata una CLASSIFICAZIONE delle immagini #library(RStoolbox)
#-valutazione della LAND COVER #library (ggplot2) e (gridExtra) per il plottaggio 
#-variabilità spaziale: calcolata con eterogeneità dell'area utilizzando la tecnica della MOVING WINDOW


install.packages("raster") #scarica e installa dal CRAN o da files locali
library(raster) #richiamo questa libreria che carica\allega i files su R
library(rgdal) #importa file raster e TIF
library(rasterVis)
library(RStoolbox)
library(ggplot2)
library(gridExtra)
setwd ("C:/lab/yellowstone/") #Windows  #setto la R Working Directory per spiegare ad R da che cartella andare a caricare il nostro dataset di immagini

#1. Times series 1987-2018
#importo le immagini usando la funzione "brick" all'interno del pacchetto raster che crear un oggetto rasterbrick (oggetto raster multi-layer)

Ys_1987beforefire<-brick("Yellowstone_19870805.jpg")
Ys_1988fire<-brick("Yellowstone_19880823.jpg")
Ys_1989afterfire<-brick("Yellowstone_19890802.jpg")
Ys_1993<-brick("Yellowstone_19930922.jpg")
Ys_1996<-brick("Yellowstone_19960712.jpg")
Ys_1998<-brick("Yellowstone_19980718.jpg")
Ys_2008<-brick("Yellowstone_20080915.jpg")
Ys_2018<-brick("yellowstone_20180222.jpg")

par(mfrow=c(2,4))  #funzione generica che permette il settaggio dei parametri grafici creando un multiframe, in questo caso plottiamo le immagini in RGB(schema red,green,blue)per visualizzare un oggetto raster multi-layer

#le immagini scaricate e processate dal sito Earth Observatory NASA avevano già le bande sono state realizzate con una combinazione di luce visibile e infrarossa (verde, infrarossi a onde corte(SWIR) e vicino all'infrarosso(NIR)) per evidenziare l'area bruciata e i cambiamenti nella vegetazione.
#se l'immagine fosse stata fatta con luce visibile, il fumo sarebbe così denso nell'immagine del 1988 denso da non permettere di vedere quasi nulla. Nell'immagine in infrarosso il fumo diventa invece una patina blu.

plotRGB(Ys_1987beforefire,1, 2, 3, stretch="Lin")  #l'argomento "stretch"(lin o hist) fa si che la riflettanza delle singole bande venga "stirata" in modo che non ci siano schiacciamenti di colori e vengano tutti mostrati.
plotRGB(Ys_1988fire,1, 2, 3, stretch="Lin")
plotRGB(Ys_1989afterfire,1, 2, 3, stretch="Lin")
plotRGB(Ys_1993,1, 2, 3, stretch="Lin")
plotRGB(Ys_1996,1, 2, 3, stretch="Lin")
plotRGB(Ys_1998,1, 2, 3, stretch="Lin")
plotRGB(Ys_2008,1, 2, 3, stretch="Lin")
plotRGB(Ys_2018,1, 2, 3, stretch="Lin")

# colorRampPalette estende la palette dei colori, i numeri che vediamo a lato dell'immagine sono i valori di riflettanza e ad ogni valore è stato associato un colore
cl <- colorRampPalette(c('dark red','red','orange','yellow'))(100)  #c creazione di un vettore o array(argomento) che racchiude i nuovi colori scelti (elementi)
plot(Ys_1988fire, col=cl)

#Utilizzando la funzione "raster" carico le singole immagini e le plotto
Ys_1987beforefireR <- raster("Yellowstone_19870805.jpg") 
cts <- colorRampPalette(c("blue","dark green","light green","orange","white")) (100)
plot(Ys_1987beforefire, col=cts)
Ys_1988fireR<-raster("Yellowstone_19880823.jpg")
plot(Ys_1988fire,col=cts)
Ys_1989afterfireR<-raster("Yellowstone_19890802.jpg")
plot(Ys_1989afterfire,col=cts)
Ys_1993R<-raster("Yellowstone_19930922.jpg")
plot(Ys_1993,col=cts)
Ys_1996R<-raster("Yellowstone_19960712.jpg")
plot(Ys_1996,col=cts)
Ys_1998R<-raster("Yellowstone_19980718.jpg")
plot(Ys_1998,col=cts)
Ys_2008R<-raster("Yellowstone_20080915.jpg")
plot(Ys_2008,col=cts)
Ys_2018R<-raster("Yellowstone_20180222.jpg")
plot(Ys_2018,col=cts)

par(mfrow=c(2,4))
plot(Ys_1987beforefireR, col=cts)
plot(Ys_1988fire,col=cts)
plot(Ys_1989afterfireR,col=cts)
plot(Ys_1993R,col=cts)
plot(Ys_1996R,col=cts)
plot(Ys_1998R,col=cts)
plot(Ys_2008R,col=cts)
plot(Ys_2018R,col=cts)

#Creiamo una lista con la funzione "list.files" e utilizziamo un "pattern" che accomuna tutti i files, in questo caso "Yellowstone_" Per importare tutte queste immagini insieme usiamo la funzione "lapply" applicabile ad una lista di file o un vettore
rlist <- list.files(pattern="Yellowstone_")
rlist

import <- lapply(rlist,raster) #alla funzione "lapply" viene applicata la funzione "raster"
import

timesYs<-stack(import) #la funzione "stack" crea un unico file partendo da una lista o un dataframe a cui associamo un nome
levelplot(timesYs) 

#Possiamo anche applicare la funzione "levelplot" considerando ogni singolo file interno a "timesYs"
levelplot(timesYs$Ys_1987beforefireR)

cl <- colorRampPalette(c("blue","light blue","pink","red"))(100)
levelplot(timesYs,col.regions=cl,main="Yellostone Park's burn recovery",names.attr=c("1987","1988", "1989", "1993","1996","1998","2008","2018"))

#2. Unsupervised classification
#in questo processo vengono accorpati pixel di un'immagine con valori simili a rappresentare una CLASSE. Ogni classe ha quindi dei pixel che corrispondono ad un determinato valore di riflettanza.

set.seed(42)  #questa funzione fa in modo che vengano utilizzate sempre le stesse repliche per il modello e che i colori rimangano gli stessi.
class1987<- unsuperClass(Ys_1987beforefire, nClasses=5)
cl <- colorRampPalette(c('black','purple','red','orange','yellow'))(100)
plot(class1987$map,col=cl)
class1988<- unsuperClass(Ys_1988fire, nClasses=5)
plot(class1988$map,col=cl)
class1989<- unsuperClass(Ys_1989afterfire, nClasses=5)
plot(class1989$map,col=cl)
class2018<- unsuperClass(Ys_2018, nClasses=5)
plot(class2018$map,col=cl)

set.seed(1)
par(mfrow=c(2,2))
plot(class1987$map,col=cl)
plot(class1988$map,col=cl)
plot(class1989$map,col=cl)
plot(class2018$map,col=cl)

#3. NDVI (indice di vegetazione normalizzato)
#ndvi
#(NIR-RED)/(NIR+RED)

#time 1
clndvi <- colorRampPalette(c('darkblue','yellow','red','black'))(100)
ndvi1 <- (Ys_1989afterfire$Yellowstone_19890802.1-Ys_1989afterfire$Yellowstone_19890802.2) / (Ys_1989afterfire$Yellowstone_19890802.1+Ys_1989afterfire$Yellowstone_19890802.2) 
plot(ndvi1, col=clndvi, main="NDVI time 1")

#time 2
ndvi2 <- (Ys_2018$yellowstone_20180222.1-Ys_2018$yellowstone_20180222.2) / (Ys_2018$yellowstone_20180222.1+Ys_2018$yellowstone_20180222.2)
plot(ndvi2, col=clndvi, main="NDVI time 2")

par(mfrow=c(1,2))
plot(ndvi1, col=clndvi)
plot(ndvi2, col=clndvi)

difndvi<-ndvi1-ndvi2
plot(difndvi,col=clndvi, main="NDVI time1-time2") #o senza la colorramppalette

#Indici spettrali
si1 <-spectralIndices(Ys_1989afterfire, green=3, red=2, nir=1)
plot(vi1, col=cl)

si2 <-spectralIndices(Ys_2018, green=3, red=2, nir=1)
plot(vi2, col=cl)

#4.Variabilità multitemporale (controllare!!!!!!)
#sull'asse x viene messo l'anno, sull'asse y il valore del pixel e viene misurata la varianza dello stesso pixel sulla stessa banda nel corso degli anni.
#Nel caso dell'incendio e della vegetazione si crea un'alta variabilità sull'omogeneità della distribuzione delle essenze vegetali. Ci sarà maggiore variazione di pixel

#worldwide NDVI
plot(copNDVI)

# Pixels with values 253, 254 and 255 (water) will be set as NA’s.
copNDVI <- reclassify(copNDVI, cbind(253:255, NA))
plot(copNDVI)

# rasterVis package needed:
levelplot(copNDVI)

#5. Land cover
#per plottare in modo migliore le immagini richiamo la library ggplot2 e gridExtra

Ys_1987beforefire<-brick("Yellowstone_19870805.jpg")
Ys_1988fire<-brick("Yellowstone_19880823.jpg")
Ys_1989afterfire<-brick("Yellowstone_19890802.jpg")
Ys_2018<-brick("yellowstone_20180222.jpg")

plotRGB(Ys_1987beforefire,1, 2, 3, stretch="Lin")
plotRGB(Ys_1988fire,1, 2, 3, stretch="Lin")
plotRGB(Ys_1989afterfire,1, 2, 3, stretch="Lin")
plotRGB(Ys_2018,1, 2, 3, stretch="Lin")

p1<-ggRGB(Ys_1987beforefire,1, 2, 3, stretch="Lin") #con questa funzione vengono visualizzate anche le coordinate spaziali del nostro oggetto(conta dei pixel sulla x e sulla y, non è un vero S.R.!)
p2<-ggRGB(Ys_1988fire,1, 2, 3, stretch="Lin")
p3<-ggRGB(Ys_1989afterfire,1, 2, 3, stretch="Lin")
p4<-ggRGB(Ys_2018,1, 2, 3, stretch="Lin")

#per unire i plot generati in questo caso utiliazziamo la funzione "grid.arrange" dalla library gridExtra. Questa funzione compone il nostro multiframe unendo varie parti in un grafico.

grid.arrange(p1, p2, p3, p4, nrow = 2)

#ora classifichiamo le immagini in 2 CLASSI
1a CLASSE = prateria (bianco)
2a CLASSE = nuvole/parte incencendiata (giallo)
3a CLASSE = foresta (verde)

#set.seed() would allow you to attain the same results
Ys1c <- unsuperClass(Ys_1987beforefire, nClasses=3)
Ys1c
plot(Ys1c$map)

Ys2c <- unsuperClass(Ys_1989afterfire, nClasses=3)
plot(Ys2c$map)

#Quanta parte di foresta è andata persa durante l'incendio del 1988? Andiamo a calcolare la frequenza dei pixel di una certa classe
#frequencies
freq(Ys1c$map)
     value   count
[1,]     1 4377087
[2,]     2  681566
[3,]     3 5660423


#calcoliamo la proporzione di pixel e sommiamo i valori
s1<-4377087+681566+5660423
s1
[1] 10719076

prop1<- freq(Ys1c$map)/s1
            value     count
[1,] 9.329162e-08 0.4083456   #prop. 40%    #40.83
[2,] 1.865832e-07 0.0635844   #prop. 0.06%  #06.35
[3,] 2.798749e-07 0.5280701   #prop. 52%    #52.80

s2<- 10719076
prop2<- freq(Ys2c$map)/s2
            value     count
[1,] 9.329162e-08 0.4371661   #43.71
[2,] 1.865832e-07 0.2003741   #20.03
[3,] 2.798749e-07 0.3624598   #36.24

#build a dataframe
cover<- c("prateria", "parte incendiata", "foresta")
percent_1987<- c(40.83,06.35,52.80)
percent_1989<- c(43.71,20.03,36.24)
          
percentages<- data.frame (cover, percent_1987, percent_1989)
percentages  
       cover percent_1987 percent_1989
1         prateria        40.83        43.71
2 parte incendiata         6.35        20.03
3          foresta        52.80        36.24

#Usando ggplot2 generiamo un dataframe
cover1<-ggplot(percentages, aes(x=cover, y=percent_1987, color=cover)) + geom_bar(stat="identity", fill="white")   
cover2<-ggplot(percentages, aes(x=cover, y=percent_1989, color=cover)) + geom_bar(stat="identity", fill="white")   
          
grid.arrange(cover1, cover2, nrow = 1) # this needs griExtra     

#6. Moving window
Ys_2018<-brick("yellowstone_20180222.jpg")
plotRGB(Ys_2018,1, 2, 3, stretch="Lin")
clndvi <- colorRampPalette(c('darkblue','yellow','red','black'))(100)

ndvi2 <- (Ys_2018$yellowstone_20180222.1-Ys_2018$yellowstone_20180222.2) / (Ys_2018$yellowstone_20180222.1+Ys_2018$yellowstone_20180222.2)
plot(ndvi2, col=clndvi, main="NDVI time 2")






#calcolo la variabilità di questa immagine con la funzione focal. La moving window, in questo caso, è una finestra mobile di 3x3 pixel che si muove nei primi 9 pixel dell'immagine e così via.
#Il pixel centrale raccoglie la dev.standard dei 9 pixel. Alla fine otterrò una nuova mappa con pixel colorati diversamente a seconda della dev.standard calcolata in una certa finestra(più la finestra è grande più mi aspetto una certa variabilità).
ndvisd3 <- focal(ndvi, w=matrix(1/9,nrow=3,ncol=3), fun=sd)
plot(ndvisd3)
clsd <- colorRampPalette(c('blue','green','pink','magenta','orange','brown','red','yellow'))(100) #
plot(ndvisd3, col=clsd)
 
#mean ndvi with focal
ndvimean3 <- focal(ndvi, w=matrix(1/9, nrow=3, ncol=3), fun=mean)
clsd <- colorRampPalette(c('blue','green','pink','magenta','orange','brown','red','yellow'))(100) # 
plot(ndvimean3, col=clsd)

ndvisd5 <- focal(ndvi, w=matrix(1/25, nrow=5, ncol=5), fun=sd)
clsd <- colorRampPalette(c('blue','green','pink','magenta','orange','brown','red','yellow'))(100) # 
plot(ndvisd5, col=clsd)

#PCA
sentpca<- rasterPCA(sent)
plot(sentpca$map)

summary(sentpca$model)
#the first PC contains 0.6736804 of the original information
 
pc1 <- sentpca$map$PC1
plot(pc1)

pc1sd5 <- focal(pc1, w=matrix(1/25, nrow=5, ncol=5), fun=sd)
clsd <- colorRampPalette(c('blue','green','pink','magenta','orange','brown','red','yellow'))(100) # 
plot(pc1sd5, col=clsd)

# pc1 <- sentpca$map$PC1
# pc1sd7 <- focal(pc1, w=matrix(1/49, nrow=7, ncol=7), fun=sd)
# plot(pc1sd7)

# With the source function you can upload code from outside!
source("source_test_lezione.r")
source("source_ggplot.r")

# https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html
# The package contains eight color scales: “viridis”, the primary choice, and five alternatives with similar properties - “magma”, “plasma”, “inferno”, “civids”, “mako”, and “rocket” -, and a rainbow color map - “turbo”.

p1 <- ggplot() +
geom_raster(pc1sd5, mapping = aes(x = x, y = y, fill = layer)) +
scale_fill_viridis()  +
ggtitle("Standard deviation of PC1 by viridis colour scale")

p2 <- ggplot() +
geom_raster(pc1sd5, mapping = aes(x = x, y = y, fill = layer)) +
scale_fill_viridis(option = "magma")  +
ggtitle("Standard deviation of PC1 by magma colour scale")

p3 <- ggplot() +
geom_raster(pc1sd5, mapping = aes(x = x, y = y, fill = layer)) +
scale_fill_viridis(option = "turbo")  +
ggtitle("Standard deviation of PC1 by turbo colour scale")

grid.arrange(p1, p2, p3, nrow = 1)

#.....................................
